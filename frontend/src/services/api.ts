import { 
  GeneratePolicyRequest, 
  GeneratePolicyResponse, 
  ValidatePolicyRequest, 
  ValidatePolicyResponse, 
  AnalyzeHistoryRequest, 
  AnalyzeHistoryResponse,
  JobStatus,
  ChatMessage
} from '../types';
import { mockValidatePolicyResponse, mockAnalyzeHistoryResponse } from './mockData';

// Simulate API delay
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

export interface ConversationalRequest extends GeneratePolicyRequest {
  conversation_id?: string;
  is_followup?: boolean;
}

export interface ConversationalResponse {
  final_answer: string;
  conversation_id: string;
  message_count: number;
  refinement_suggestions: string[];
  security_score: number;
  security_notes: string[];
  score_breakdown?: Record<string, number>;
  conversation_history: ChatMessage[];
}

export const generatePolicy = async (
  request: ConversationalRequest
): Promise<GeneratePolicyResponse> => {
  const response = await fetch('http://localhost:8000/generate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      description: request.description,
      service: request.service,
      conversation_id: request.conversation_id || null,
      is_followup: request.is_followup || false
    }),
  });

  if (!response.ok) {
    throw new Error('Network response from agent backend was not ok');
  }

  const backendResponse: ConversationalResponse = await response.json();
  const messageContent = backendResponse.final_answer;

  // Check if messageContent exists
  if (!messageContent) {
    throw new Error("No response received from the agent backend.");
  }

  // Ensure messageContent is a string
  let contentString = typeof messageContent === 'string' ? messageContent : JSON.stringify(messageContent);

  console.log("Raw agent response:", contentString); // Debug log

  // Try to find JSON code block
  const policyMatch = contentString.match(/```json\n([\s\S]*?)\n```/);

  let policyJson;
  let explanationText = "No explanation provided.";

  if (policyMatch && policyMatch.length >= 2) {
    try {
      policyJson = JSON.parse(policyMatch[1]);
      
      // FIXED: More flexible explanation extraction
      // Try multiple patterns to extract explanation
      
      // Pattern 1: **Explanation:**
      let explanationMatch = contentString.match(/\*\*Explanation:\*\*\s*([\s\S]*?)$/i);
      
      // Pattern 2: Explanation: (without asterisks)
      if (!explanationMatch) {
        explanationMatch = contentString.match(/Explanation:\s*([\s\S]*?)$/i);
      }
      
      // Pattern 3: Everything after the JSON block
      if (!explanationMatch) {
        const afterJson = contentString.split('```')[2]; // Get text after closing ```
        if (afterJson && afterJson.trim()) {
          explanationText = afterJson.trim();
        }
      } else {
        explanationText = explanationMatch[1].trim();
      }
      
      // Clean up the explanation text
      explanationText = explanationText
        .replace(/^\*\*Explanation:\*\*/i, '') // Remove any leading "**Explanation:**"
        .replace(/^Explanation:/i, '')         // Remove any leading "Explanation:"
        .trim();
      
      console.log("Extracted explanation:", explanationText); // Debug log
      
    } catch (e) {
      console.error("Failed to parse policy JSON:", e);
      throw new Error("Failed to parse policy JSON from agent response.");
    }
  } else {
    console.warn("No JSON block found in response, using fallback");
    // Fallback policy
    policyJson = {
      "Version": "2012-10-17",
      "Statement": [
        {
          "Effect": "Allow",
          "Action": ["s3:GetObject"],
          "Resource": ["arn:aws:s3:::example-bucket/*"]
        }
      ]
    };
    explanationText = `Agent response: ${contentString}`;
  }

  // Return response with safe defaults for all expected fields
  return {
    policy: policyJson,
    explanation: explanationText,
    security_score: backendResponse.security_score || 85,
    security_notes: backendResponse.security_notes || backendResponse.refinement_suggestions || [],
    reasoning: {
      plan: "Generated by AI agent",
      actions: ["Policy created with least privilege principles"],
      reflection: "Policy follows security best practices"
    },
    conversation_id: backendResponse.conversation_id,
    refinement_suggestions: backendResponse.refinement_suggestions || [],
    conversation_history: backendResponse.conversation_history || []
  };
};

export const sendFollowUp = async (
  message: string,
  conversationId: string,
  service: string
): Promise<GeneratePolicyResponse> => {
  console.log("Sending follow-up:", { message, conversationId, service }); // Debug log
  return generatePolicy({
    description: message,
    service: service,
    restrictive: true,
    compliance: 'general',
    conversation_id: conversationId,
    is_followup: true
  });
};

export const getConversationHistory = async (conversationId: string): Promise<{
  conversation_id: string;
  messages: ChatMessage[];
  message_count: number;
}> => {
  const response = await fetch(`http://localhost:8000/conversation/${conversationId}`);
  if (!response.ok) {
    throw new Error('Failed to fetch conversation history');
  }
  return response.json();
};

export const clearConversation = async (conversationId: string) => {
  const response = await fetch(`http://localhost:8000/conversation/${conversationId}`, {
    method: 'DELETE'
  });
  if (!response.ok) {
    throw new Error('Failed to clear conversation');
  }
  return response.json();
};

export const validatePolicy = async (request: ValidatePolicyRequest): Promise<ValidatePolicyResponse> => {
  await delay(1500);
  const response = mockValidatePolicyResponse(request);
  return response;
};

export const analyzeHistory = async (request: AnalyzeHistoryRequest): Promise<AnalyzeHistoryResponse> => {
  await delay(3000);
  const response = mockAnalyzeHistoryResponse(request);
  return response;
};

export const getJobStatus = async (jobId: string): Promise<JobStatus> => {
  await delay(2000);
  const progress = Math.min(100, Math.floor(Math.random() * 30) + 70);
  
  return {
    id: jobId,
    status: progress >= 100 ? 'completed' : 'running',
    progress,
    estimated_completion: progress >= 100 ? 'Complete' : `${Math.floor((100 - progress) / 10)} minutes`,
    message: progress >= 100 
      ? 'Analysis complete - optimized policy generated'
      : 'Analyzing CloudTrail logs and usage patterns...'
  };
};