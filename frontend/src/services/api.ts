import { 
  GeneratePolicyRequest, 
  GeneratePolicyResponse, 
  ValidatePolicyRequest, 
  ValidatePolicyResponse, 
  AnalyzeHistoryRequest, 
  AnalyzeHistoryResponse,
  JobStatus,
  ChatMessage
} from '../types';

// API URL - uses environment variable on Vercel, localhost for local development
const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000';

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

export interface ConversationalRequest {
  description: string;
  compliance?: string;
  restrictive?: boolean;
  conversation_id?: string;
  is_followup?: boolean;
}

export interface ConversationalResponse {
  final_answer: string;
  conversation_id: string;
  message_count: number;
  refinement_suggestions: string[];
  security_score: number;
  security_notes: string[];
  score_breakdown?: Record<string, number>;
  score_explanation?: string;
  security_features?: string[];
  conversation_history: ChatMessage[];
  policy?: any;
  explanation?: string;
  is_question?: boolean;
}

export const generatePolicy = async (
  request: ConversationalRequest
): Promise<GeneratePolicyResponse> => {
  const response = await fetch(`${API_URL}/generate`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      description: request.description,
      service: 'lambda',
      conversation_id: request.conversation_id || null,
      is_followup: request.is_followup || false,
      restrictive: request.restrictive || false,
      compliance: request.compliance || 'general'
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Backend error: ${response.status} - ${errorText}`);
  }

  const backendResponse: ConversationalResponse = await response.json();
  const messageContent = backendResponse.final_answer;

  if (!messageContent) {
    throw new Error("No response received from the agent backend.");
  }

  if (backendResponse.is_question || !backendResponse.policy) {
    return {
      policy: null,
      explanation: messageContent,
      security_score: 0,
      security_notes: [],
      score_breakdown: {},
      score_explanation: "Agent is requesting more information.",
      security_features: [],
      reasoning: {
        plan: "Gathering required information",
        actions: ["Requesting AWS Account ID, Region, or other details"],
        reflection: "Cannot generate policy without complete information"
      },
      conversation_id: backendResponse.conversation_id,
      refinement_suggestions: [],
      conversation_history: backendResponse.conversation_history || [],
      is_question: true
    };
  }

  return {
    policy: backendResponse.policy,
    explanation: backendResponse.explanation || "Policy generated successfully.",
    security_score: backendResponse.security_score || 0,
    security_notes: backendResponse.security_notes || [],
    score_breakdown: backendResponse.score_breakdown || {},
    score_explanation: backendResponse.score_explanation || "",
    security_features: backendResponse.security_features || [],
    reasoning: {
      plan: "Generated by AI agent with security best practices",
      actions: ["Policy created with least privilege principles"],
      reflection: "Policy follows AWS security best practices"
    },
    conversation_id: backendResponse.conversation_id,
    refinement_suggestions: backendResponse.refinement_suggestions || [],
    conversation_history: backendResponse.conversation_history || []
  };
};

export const sendFollowUp = async (
  message: string,
  conversationId: string
): Promise<GeneratePolicyResponse> => {
  return generatePolicy({
    description: message,
    restrictive: true,
    compliance: 'general',
    conversation_id: conversationId,
    is_followup: true
  });
};

export const getConversationHistory = async (conversationId: string): Promise<{
  conversation_id: string;
  messages: ChatMessage[];
  message_count: number;
}> => {
  const response = await fetch(`${API_URL}/conversation/${conversationId}`);
  if (!response.ok) {
    throw new Error('Failed to fetch conversation history');
  }
  return response.json();
};

export const clearConversation = async (conversationId: string) => {
  const response = await fetch(`${API_URL}/conversation/${conversationId}`, {
    method: 'DELETE'
  });
  if (!response.ok) {
    throw new Error('Failed to clear conversation');
  }
  return response.json();
};

// ============================================
// VALIDATION API (MCP-ENABLED)
// ============================================

export const validatePolicy = async (request: ValidatePolicyRequest): Promise<ValidatePolicyResponse> => {
  // Determine mode based on what's provided
  const mode = request.policy_json || request.role_arn ? 'quick' : 'audit';
  
  const response = await fetch(`${API_URL}/validate`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      policy_json: request.policy_json || null,
      role_arn: request.role_arn || null,
      compliance_frameworks: request.compliance_frameworks || ['pci_dss', 'hipaa', 'sox', 'gdpr', 'cis'],
      mode: mode
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Validation failed: ${response.status} - ${errorText}`);
  }

  const backendResponse = await response.json();
  
  if (!backendResponse.success) {
    throw new Error(backendResponse.error || 'Validation failed');
  }

  return {
    findings: backendResponse.findings || [],
    risk_score: backendResponse.risk_score || 50,
    security_issues: backendResponse.findings?.map((f: any) => f.description) || [],
    recommendations: backendResponse.recommendations || [],
    compliance_status: backendResponse.compliance_status || {},
    quick_wins: backendResponse.quick_wins || [],
    audit_summary: backendResponse.audit_summary || null,
    top_risks: backendResponse.top_risks || []
  };
};

// ============================================
// AUTONOMOUS AUDIT API (MCP-ENABLED)
// ============================================

export interface AuditRequest {
  compliance_frameworks?: string[];
}

export interface AuditResponse {
  success: boolean;
  audit_summary: {
    total_roles: number;
    roles_analyzed: number;
    total_policies: number;
    total_findings: number;
    critical_findings: number;
    high_findings: number;
    medium_findings: number;
    low_findings: number;
  };
  risk_score: number;
  top_risks: Array<{
    role_name: string;
    risk_score: number;
    critical_issues: number;
    findings: any[];
  }>;
  findings: any[];
  compliance_status: Record<string, any>;
  recommendations: string[];
  quick_wins: string[];
  raw_response: string;
  mcp_enabled: boolean;
}

export const performAutonomousAudit = async (
  request: AuditRequest = {}
): Promise<ValidatePolicyResponse> => {
  const response = await fetch(`${API_URL}/audit`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      compliance_frameworks: request.compliance_frameworks || ['pci_dss', 'hipaa', 'sox', 'gdpr', 'cis']
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Audit failed: ${response.status} - ${errorText}`);
  }

  const result = await response.json();
  
  if (!result.success) {
    throw new Error(result.error || 'Audit failed');
  }

  // Convert audit response to ValidatePolicyResponse format
  return {
    findings: result.findings || [],
    risk_score: result.risk_score || 50,
    security_issues: result.findings?.map((f: any) => f.description) || [],
    recommendations: result.recommendations || [],
    compliance_status: result.compliance_status || {},
    quick_wins: result.quick_wins || [],
    audit_summary: result.audit_summary || null,
    top_risks: result.top_risks || []
  };
};

// ============================================
// ANALYZE HISTORY (MOCK FOR NOW)
// ============================================

export const analyzeHistory = async (request: AnalyzeHistoryRequest): Promise<AnalyzeHistoryResponse> => {
  // Mock implementation - will be replaced with real CloudTrail analysis
  await delay(3000);
  
  return {
    risk_reduction: 78,
    usage_summary: {
      total_permissions: 120,
      used_permissions: 26,
      unused_permissions: 94,
      usage_percentage: 22,
    },
    optimized_policy: {
      Version: "2012-10-17",
      Statement: [
        {
          Effect: "Allow",
          Action: "s3:GetObject",
          Resource: "arn:aws:s3:::specific-bucket/*"
        }
      ]
    },
    implementation_steps: [
      "Review the optimized policy to ensure it meets business needs.",
      "Create a new IAM policy version with the optimized JSON.",
      "Set the new policy version as the default for the role.",
      "Monitor application functionality after deployment."
    ],
    security_improvements: [
      "Reduced attack surface by removing 94 unused permissions.",
      "Enforced least privilege based on actual usage.",
      "Eliminated potential privilege escalation paths."
    ]
  };
};